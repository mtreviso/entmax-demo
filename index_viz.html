<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>α-entmax Viz</title>
  <link rel="icon" href="alpha.png">
  <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.0/es5/tex-mml-chtml.js"></script>
  <style>
    .viz-container { 
      width: 100%; 
      height: 600px; 
      background: white; 
      border-radius: 8px; 
      box-shadow: 0 2px 8px rgba(0,0,0,0.1); 
    }
    .small-viz { height: 460px; }
  </style>
</head>
<body class="bg-gray-50 text-gray-900 min-h-screen p-6">
  <div class="max-w-7xl mx-auto">
    <header class="mb-8 text-center">
      <h1 class="text-4xl font-bold text-indigo-800 mb-2">α-entmax Viz</h1>
      <p class="text-gray-600">2d, 3d, convergence</p>
    </header>

    <!-- Main Tabs -->
    <div class="mb-6 border-b border-gray-200">
      <nav class="flex space-x-4 overflow-x-auto">
        <button class="tab-button px-4 py-2 font-medium border-b-2 border-transparent text-gray-500 hover:text-gray-700" data-tab="2d-slices">2D Slices</button>
        <button class="tab-button px-4 py-2 font-medium border-b-2 border-indigo-600 text-indigo-600" data-tab="3d-surfaces">3D Surfaces</button>
        <button class="tab-button px-4 py-2 font-medium border-b-2 border-transparent text-gray-500 hover:text-gray-700" data-tab="comparison">3D Side-by-Side</button>
        <button class="tab-button px-4 py-2 font-medium border-b-2 border-transparent text-gray-500 hover:text-gray-700" data-tab="f-tau">f(τ) Visualization</button>
        <button class="tab-button px-4 py-2 font-medium border-b-2 border-transparent text-gray-500 hover:text-gray-700" data-tab="convergence">Convergence</button>
      </nav>
    </div>

    <!-- 3D Surfaces Tab -->
    <div class="tab-panel" data-panel="3d-surfaces">
      <div class="bg-white rounded-lg shadow-md p-6 mb-6">
        <h2 class="text-2xl font-bold text-gray-800 mb-4">3D Surface: p₁(z₂, z₃) with z₁=0</h2>

        <div class="grid grid-cols-1 md:grid-cols-4 gap-4 mb-6">
          <div>
            <label class="block text-sm font-medium text-gray-700 mb-2">Transformation</label>
            <select id="method-3d" class="w-full px-3 py-2 border border-gray-300 rounded-md">
              <option value="entmax">α-entmax</option>
              <option value="softmax">Softmax</option>
              <option value="sparsemax">Sparsemax</option>
              <option value="normmax">Normmax</option>
              <option value="topk">Top-k</option>
              <option value="relu-norm">ReLU Norm</option>
              <option value="budget">Budget</option>
            </select>
          </div>
          <div id="param-alpha-3d">
            <label class="block text-sm font-medium text-gray-700 mb-2">α (entmax/normmax)</label>
            <input type="range" id="alpha-3d" min="1.01" max="5" step="0.01" value="1.5" class="w-full">
            <span id="alpha-3d-value" class="text-sm text-gray-600">1.50</span>
          </div>
          <div id="param-k-3d" class="hidden">
            <label class="block text-sm font-medium text-gray-700 mb-2">k (top-k)</label>
            <input type="range" id="k-3d" min="1" max="3" step="1" value="1" class="w-full">
            <span id="k-3d-value" class="text-sm text-gray-600">1</span>
          </div>
          <div id="param-b-3d" class="hidden">
            <label class="block text-sm font-medium text-gray-700 mb-2">b (ReLU norm)</label>
            <input type="range" id="b-3d" min="0.1" max="5" step="0.1" value="1" class="w-full">
            <span id="b-3d-value" class="text-sm text-gray-600">1.0</span>
          </div>
          <div id="param-budget-3d" class="hidden">
            <label class="block text-sm font-medium text-gray-700 mb-2">Budget (budget)</label>
            <input type="range" id="budget-3d" min="0.5" max="3" step="0.1" value="1" class="w-full">
            <span id="budget-3d-value" class="text-sm text-gray-600">1.0</span>
          </div>
        </div>

        <div class="grid grid-cols-1 md:grid-cols-3 gap-4 mb-6">
          <div>
            <label class="block text-sm font-medium text-gray-700 mb-2">Output Component</label>
            <select id="component-3d" class="w-full px-3 py-2 border border-gray-300 rounded-md">
              <option value="0">p₁</option>
              <option value="1">p₂</option>
              <option value="2">p₃</option>
            </select>
          </div>
          <div>
            <label class="block text-sm font-medium text-gray-700 mb-2">z range</label>
            <input type="range" id="z-range" min="1" max="5" step="0.5" value="3" class="w-full">
            <span id="z-range-value" class="text-sm text-gray-600">±3</span>
          </div>
          <div>
            <label class="block text-sm font-medium text-gray-700 mb-2">Resolution</label>
            <input type="range" id="resolution-3d" min="20" max="100" step="5" value="50" class="w-full">
            <span id="resolution-3d-value" class="text-sm text-gray-600">50</span>
          </div>
        </div>

        <div id="plot-3d-surface" class="viz-container"></div>
      </div>
    </div>

    <!-- 2D Slices Tab -->
    <div class="tab-panel hidden" data-panel="2d-slices">
      <div class="bg-white rounded-lg shadow-md p-6 mb-6">
        <h2 class="text-2xl font-bold text-gray-800 mb-4">2D slice with selected methods (z₂…zₙ=0)</h2>

        <div class="grid grid-cols-1 md:grid-cols-6 gap-4 mb-4">
          <div>
            <label class="block text-xs text-gray-700 mb-1">n (components)</label>
            <input type="range" id="n-components" min="2" max="5" step="1" value="2" class="w-full">
            <span id="n-components-value" class="text-sm text-gray-600">2</span>
          </div>
          <div>
            <label class="block text-xs text-gray-700 mb-1">α (entmax)</label>
            <input type="range" id="alpha-entmax" min="1.01" max="5" step="0.01" value="1.5" class="w-full">
            <span id="alpha-entmax-value" class="text-sm text-gray-600">1.50</span>
          </div>
          <div>
            <label class="block text-xs text-gray-700 mb-1">α (normmax)</label>
            <input type="range" id="alpha-normmax" min="1.01" max="5" step="0.01" value="2.0" class="w-full">
            <span id="alpha-normmax-value" class="text-sm text-gray-600">2.00</span>
          </div>
          <div>
            <label class="block text-xs text-gray-700 mb-1">k (top-k)</label>
            <input type="range" id="k-topk" min="1" max="5" step="1" value="1" class="w-full">
            <span id="k-topk-value" class="text-sm text-gray-600">1</span>
          </div>
          <div>
            <label class="block text-xs text-gray-700 mb-1">b (ReLU norm)</label>
            <input type="range" id="b-relu" min="0.1" max="5" step="0.1" value="1.0" class="w-full">
            <span id="b-relu-value" class="text-sm text-gray-600">1.0</span>
          </div>
          <div>
            <label class="block text-xs text-gray-700 mb-1">Budget (budget)</label>
            <input type="range" id="budget-val" min="0.5" max="5" step="0.1" value="1.0" class="w-full">
            <span id="budget-val-value" class="text-sm text-gray-600">1.0</span>
          </div>
        </div>

        <div class="mb-4">
          <label class="block text-sm font-medium text-gray-700 mb-2">Select methods to display:</label>
          <div class="flex flex-wrap gap-4">
            <label class="inline-flex items-center gap-2">
              <input type="checkbox" id="show-softmax" class="h-4 w-4" checked>
              <span class="text-sm text-gray-700">Softmax</span>
            </label>
            <label class="inline-flex items-center gap-2">
              <input type="checkbox" id="show-entmax" class="h-4 w-4" checked>
              <span class="text-sm text-gray-700">α-entmax</span>
            </label>
            <label class="inline-flex items-center gap-2">
              <input type="checkbox" id="show-sparsemax" class="h-4 w-4" checked>
              <span class="text-sm text-gray-700">Sparsemax</span>
            </label>
            <label class="inline-flex items-center gap-2">
              <input type="checkbox" id="show-normmax" class="h-4 w-4" checked>
              <span class="text-sm text-gray-700">Normmax</span>
            </label>
            <label class="inline-flex items-center gap-2">
              <input type="checkbox" id="show-topk" class="h-4 w-4" checked>
              <span class="text-sm text-gray-700">Top-k</span>
            </label>
            <label class="inline-flex items-center gap-2">
              <input type="checkbox" id="show-relu" class="h-4 w-4" checked>
              <span class="text-sm text-gray-700">ReLU Norm</span>
            </label>
            <label class="inline-flex items-center gap-2">
              <input type="checkbox" id="show-budget" class="h-4 w-4" checked>
              <span class="text-sm text-gray-700">Budget</span>
            </label>
          </div>
        </div>

        <div id="plot-2d-slice" class="viz-container"></div>
      </div>
    </div>

    <!-- Side-by-Side Tab -->
    <div class="tab-panel hidden" data-panel="comparison">
      <div class="bg-white rounded-lg shadow-md p-6 mb-6">
        <h2 class="text-2xl font-bold text-gray-800 mb-4">Side-by-side (max 3)</h2>

        <div class="grid grid-cols-1 md:grid-cols-3 gap-4 mb-4">
          <!-- Method 1 -->
          <div class="border rounded p-3">
            <div class="font-semibold mb-2">Panel A</div>
            <select id="m1" class="w-full mb-2 border rounded px-2 py-1">
              <option value="softmax">Softmax</option>
              <option value="entmax" selected>α-entmax</option>
              <option value="sparsemax">Sparsemax</option>
              <option value="normmax">Normmax</option>
              <option value="topk">Top-k</option>
              <option value="relu-norm">ReLU Norm</option>
              <option value="budget">Budget</option>
              <option value="">None</option>
            </select>
            <div id="m1-params"></div>
          </div>
          <!-- Method 2 -->
          <div class="border rounded p-3">
            <div class="font-semibold mb-2">Panel B</div>
            <select id="m2" class="w-full mb-2 border rounded px-2 py-1">
              <option value="softmax">Softmax</option>
              <option value="entmax">α-entmax</option>
              <option value="sparsemax" selected>Sparsemax</option>
              <option value="normmax">Normmax</option>
              <option value="topk">Top-k</option>
              <option value="relu-norm">ReLU Norm</option>
              <option value="budget">Budget</option>
              <option value="">None</option>
            </select>
            <div id="m2-params"></div>
          </div>
          <!-- Method 3 -->
          <div class="border rounded p-3">
            <div class="font-semibold mb-2">Panel C</div>
            <select id="m3" class="w-full mb-2 border rounded px-2 py-1">
              <option value="softmax" selected>Softmax</option>
              <option value="entmax">α-entmax</option>
              <option value="sparsemax">Sparsemax</option>
              <option value="normmax">Normmax</option>
              <option value="topk">Top-k</option>
              <option value="relu-norm">ReLU Norm</option>
              <option value="budget">Budget</option>
              <option value="">None</option>
            </select>
            <div id="m3-params"></div>
          </div>
        </div>

        <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
          <div id="plot-comp-a" class="viz-container"></div>
          <div id="plot-comp-b" class="viz-container"></div>
          <div id="plot-comp-c" class="viz-container"></div>
        </div>
      </div>
    </div>

    <!-- f(τ) Visualization Tab -->
    <div class="tab-panel hidden" data-panel="f-tau">
      <div class="bg-white rounded-lg shadow-md p-6 mb-6">
        <h2 class="text-2xl font-bold text-gray-800 mb-4">f(τ) with higher derivatives</h2>

        <div class="grid grid-cols-1 md:grid-cols-4 gap-4 mb-6">
          <div>
            <label class="block text-sm font-medium text-gray-700 mb-2">Preset</label>
            <select id="preset-ftau" class="w-full px-3 py-2 border border-gray-300 rounded-md">
              <option value="custom">Custom</option>
              <option value="uniform">Uniform (0, 0, 0, 0, 0)</option>
              <option value="slight">Slight variation (0.1, 0.2, 0.3, 0.4, 0.5)</option>
              <option value="moderate" selected>Moderate (0.2, 0.5, 0.7, 0.9, 1.2)</option>
              <option value="extreme">Extreme (0, 1, 2, 3, 5)</option>
              <option value="negative">With negatives (-1, -0.5, 0, 0.5, 1)</option>
            </select>
          </div>
          <div class="md:col-span-2">
            <label class="block text-sm font-medium text-gray-700 mb-2">Scores (comma-separated)</label>
            <input type="text" id="scores-ftau" value="0.2, 0.5, 0.7, 0.9, 1.2" class="w-full px-3 py-2 border border-gray-300 rounded-md">
          </div>
          <div>
            <label class="block text-sm font-medium text-gray-700 mb-2">α value</label>
            <input type="range" id="alpha-ftau" min="1.01" max="5" step="0.01" value="1.5" class="w-full">
            <span id="alpha-ftau-value" class="text-sm text-gray-600">1.50</span>
          </div>
        </div>

        <div class="mb-4 flex items-center justify-between">
          <div>
            <label class="block text-sm font-medium text-gray-700 mb-2">Select derivatives to show:</label>
            <div class="flex flex-wrap gap-4">
              <label class="inline-flex items-center gap-2">
                <input type="checkbox" id="show-f" class="h-4 w-4" checked>
                <span class="text-sm text-gray-700">f(τ)</span>
              </label>
              <label class="inline-flex items-center gap-2">
                <input type="checkbox" id="show-d1" class="h-4 w-4" checked>
                <span class="text-sm text-gray-700">f'(τ)</span>
              </label>
              <label class="inline-flex items-center gap-2">
                <input type="checkbox" id="show-d2" class="h-4 w-4" checked>
                <span class="text-sm text-gray-700">f''(τ)</span>
              </label>
              <label class="inline-flex items-center gap-2">
                <input type="checkbox" id="show-d3" class="h-4 w-4">
                <span class="text-sm text-gray-700">f'''(τ)</span>
              </label>
              <label class="inline-flex items-center gap-2">
                <input type="checkbox" id="show-d4" class="h-4 w-4">
                <span class="text-sm text-gray-700">f⁽⁴⁾(τ)</span>
              </label>
            </div>
          </div>
          <div class="text-right">
            <div class="text-sm font-medium text-gray-700">Optimal τ*:</div>
            <div id="tau-star-value" class="text-lg font-bold text-indigo-600">--</div>
          </div>
        </div>

        <div id="plot-ftau" class="viz-container small-viz"></div>
      </div>
    </div>

    <!-- Convergence Tab -->
    <div class="tab-panel hidden" data-panel="convergence">
      <div class="bg-white rounded-lg shadow-md p-6 mb-6">
        <h2 class="text-2xl font-bold text-gray-800 mb-4">Root finding: choose a method</h2>

        <div class="grid grid-cols-1 md:grid-cols-4 gap-4 mb-6">
          <div class="md:col-span-2">
            <label class="block text-sm font-medium text-gray-700 mb-2">Scores (comma-separated)</label>
            <input type="text" id="scores-conv" value="0.2, 0.5, 0.7, 0.9, 1.2" class="w-full px-3 py-2 border border-gray-300 rounded-md">
          </div>
          <div>
            <label class="block text-sm font-medium text-gray-700 mb-2">α value</label>
            <input type="range" id="alpha-conv" min="1.01" max="5" step="0.01" value="1.5" class="w-full">
            <span id="alpha-conv-value" class="text-sm text-gray-600">1.50</span>
          </div>
          <div>
            <label class="block text-sm font-medium text-gray-700 mb-2">Method</label>
            <select id="method-conv" class="w-full px-3 py-2 border border-gray-300 rounded-md">
              <option value="newton" selected>Newton</option>
              <option value="bisection">Bisection</option>
              <option value="secant">Secant</option>
              <option value="halley">Halley</option>
            </select>
          </div>
        </div>

        <div class="mb-4">
          <label class="block text-sm font-medium text-gray-700 mb-2">Initial τ (restricted to theoretical bisection bounds)</label>
          <input type="range" id="tau-init" min="0" max="1" step="0.01" value="0.5" class="w-full">
          <span id="tau-init-value" class="text-sm text-gray-600">--</span>
        </div>

        <div id="plot-convergence" class="viz-container mb-4"></div>
      </div>
    </div>


    <!-- Mathematical Definitions -->
    <div class="mt-8 bg-white rounded-lg shadow-md p-6">
      <h2 class="text-xl font-bold text-indigo-800 mb-4">Mathematical definition of α-entmax</h2>
      <div class="math-container">
        <p>The \(\alpha\)-entmax transformation of a score vector
        \(\boldsymbol{z} \in \mathbb{R}^n\) is defined as:</p>
        
        \[
        \alpha\text{-entmax}(\boldsymbol{z})
        =
        \arg\max_{\boldsymbol{p} \,\in\, \triangle_n}
        \boldsymbol{p}^\top \boldsymbol{z} + H_\alpha(\boldsymbol{p}),
        \quad
        \triangle_n
        = \bigl\{\boldsymbol{p} \in \mathbb{R}^n_{+}:\sum_{i=1}^n p_i = 1\bigr\},
        \]
        
        <p class="mt-4">where \(H_\alpha(\boldsymbol{p})\) is the Tsallis(\(\alpha\)) entropy. The closed form for
        \(\alpha\text{-entmax}\) with \(\alpha > 1\) is:</p>
        
        \[
        p_i^\star
        =
        \bigl[(\alpha-1)\,z_i - \tau(\boldsymbol{z})\bigr]_+^{\tfrac{1}{\alpha-1}},
        \quad
        \sum_{i=1}^n p_i^\star = 1,
        \quad
        [\cdot]_+ = \max(0,\cdot).
        \]
        
        <p class="mt-4">Here, \(\tau(\boldsymbol{z})\) is chosen so that \(\boldsymbol{p}^\star\) sums to 1.</p>
      </div>
      
      <div class="mt-6 border-t pt-4">
        <h3 class="text-lg font-semibold text-gray-700 mb-2">Citation</h3>
        <p class="text-sm text-gray-600">
          Ben Peters, Vlad Niculae, and André F. T. Martins. 2019. Sparse sequence-to-sequence models. 
          In <em>Proceedings of the 57th Annual Meeting of the Association for Computational Linguistics</em>, 
          pages 1504–1519, Florence, Italy. Association for Computational Linguistics.
          <a href="https://arxiv.org/abs/1905.05702" class="text-indigo-600 hover:text-indigo-800" target="_blank">
            https://arxiv.org/abs/1905.05702
          </a>
        </p>
      </div>
    </div>
  </div>

<script>
// ================= Global state for persistent legend visibility =================
const legendState = {
  '3d-surface': {},
  '2d-slice': {},
  'comparison-a': {},
  'comparison-b': {},
  'comparison-c': {},
  'ftau': {},
  'convergence': {}
};

// ================= Core math =================
function entmax(scores, alpha, nIter = 50) {
  const n = scores.length;
  const maxScore = Math.max(...scores);
  const X = scores.map(s => s * (alpha - 1));
  const maxVal = maxScore * (alpha - 1);
  let tauLo = maxVal - Math.pow(1, alpha - 1);
  let tauHi = maxVal - Math.pow(1 / n, alpha - 1);
  let dm = tauHi - tauLo;
  let pM = null;
  for (let it = 0; it < nIter; it++) {
    dm /= 2;
    const tauM = tauLo + dm;
    pM = X.map(xi => {
      const diff = xi - tauM;
      return diff > 0 ? Math.pow(diff, 1 / (alpha - 1)) : 0;
    });
    const sumPM = pM.reduce((a,b)=>a+b,0);
    const fM = sumPM - 1;
    if (fM >= 0) tauLo = tauM;
  }
  const sumPM = pM.reduce((a,b)=>a+b,0);
  if (sumPM > 0) pM = pM.map(p => p / sumPM);
  return pM;
}

function softmax(scores){
  const m = Math.max(...scores);
  const ex = scores.map(s => Math.exp(s - m));
  const s = ex.reduce((a,b)=>a+b,0);
  return ex.map(e => e/s);
}

function sparsemax(scores){ return entmax(scores, 2.0); }

function topk(scores, k){
  const idx = scores.map((s,i)=>({s,i})).sort((a,b)=>b.s-a.s);
  const out = new Array(scores.length).fill(0);
  for (let i=0;i<Math.min(k, scores.length);i++) out[idx[i].i] = 1/Math.min(k, scores.length);
  return out;
}

function normmax(scores, alpha, nIter = 50){
  const n = scores.length;
  const maxScore = Math.max(...scores);
  
  // Note: NO transformation of scores by (alpha-1) for normmax
  let tauLo = maxScore - 1;
  let tauHi = maxScore - Math.pow(1 / n, alpha - 1);
  let dm = tauHi - tauLo;
  let pM = null;
  
  for (let it = 0; it < nIter; it++) {
    dm /= 2;
    const tauM = tauLo + dm;
    pM = scores.map(s => {
      const diff = s - tauM;
      return diff > 0 ? Math.pow(diff, 1 / (alpha - 1)) : 0;
    });
    // Constraint: sum(p^alpha) = 1, not sum(p) = 1
    const fM = pM.reduce((sum, p) => sum + Math.pow(p, alpha), 0) - 1;
    if (fM >= 0) tauLo = tauM;
  }
  
  const sumPM = pM.reduce((a, b) => a + b, 0);
  if (sumPM > 0) pM = pM.map(p => p / sumPM);
  return pM;
}

function reluNorm(scores, b){
  const m = Math.max(...scores);
  const zRelu = scores.map(z => Math.max(0, z - (m - b)));
  const sum = zRelu.reduce((a, v) => a + v, 0) + 1e-12;
  return zRelu.map(z => z / sum);
}

function budget(scores, B, nIter = 50){
  const n = scores.length;
  const minScore = Math.min(...scores);
  const maxScore = Math.max(...scores);
  
  let tauLo = minScore - B / n;
  let tauHi = maxScore - B / n;
  let dm = tauHi - tauLo;
  let pM = null;
  
  for (let it = 0; it < nIter; it++) {
    dm /= 2;
    const tauM = tauLo + dm;
    pM = scores.map(s => {
      const diff = s - tauM;
      // Note: clamp between 0 and 1 (not just 0)
      return Math.max(0, Math.min(1, diff));
    });
    const fM = pM.reduce((a, b) => a + b, 0) - B;
    if (fM >= 0) tauLo = tauM;
  }
  
  // No normalization for budget! Returns as-is
  return pM;
}

function applyTransform(scores, method, params){
  if (method==='softmax') return softmax(scores);
  if (method==='entmax') return entmax(scores, params.alpha || 1.5);
  if (method==='sparsemax') return sparsemax(scores);
  if (method==='normmax') return normmax(scores, params.alpha || 2.0);
  if (method==='topk') return topk(scores, params.k || 2);
  if (method==='relu-norm') return reluNorm(scores, params.b || 1.0);
  if (method==='budget') return budget(scores, params.budget || 2.0);
  return scores;
}

// f and derivatives for entmax threshold
function f(scores, tau, alpha){
  const X = scores.map(s => s * (alpha - 1));
  let sum = 0;
  for (const xi of X){
    const d = xi - tau;
    if (d > 0) sum += Math.pow(d, 1/(alpha-1));
  }
  return sum - 1;
}

function fDeriv(scores, tau, alpha, order){
  const r = 1/(alpha-1);
  const X = scores.map(s => s * (alpha - 1));
  let coeff = 1;
  for (let k=0;k<order;k++){ coeff *= (r - k); }
  const sign = Math.pow(-1, order);
  let sum = 0;
  for (const xi of X){
    const d = xi - tau;
    if (d > 0) sum += Math.pow(d, r - order);
  }
  return sign * coeff * sum;
}

function fSecondDeriv(scores, tau, alpha){ return fDeriv(scores, tau, alpha, 2); }

function findTau(scores, alpha){
  const n = scores.length;
  const maxScore = Math.max(...scores);
  const X = scores.map(s => s * (alpha - 1));
  const maxVal = maxScore * (alpha - 1);
  let tauLo = maxVal - Math.pow(1, alpha - 1);
  let tauHi = maxVal - Math.pow(1 / n, alpha - 1);
  let dm = tauHi - tauLo;
  for (let it = 0; it < 50; it++) {
    dm /= 2;
    const tauM = tauLo + dm;
    const pM = X.map(xi => {
      const diff = xi - tauM;
      return diff > 0 ? Math.pow(diff, 1 / (alpha - 1)) : 0;
    });
    const sumPM = pM.reduce((a,b)=>a+b,0);
    const fM = sumPM - 1;
    if (fM >= 0) tauLo = tauM;
  }
  return tauLo + dm;
}

// ======== 3D Surface ========
function updateParamVisibility3D(){
  const method = document.getElementById('method-3d').value;
  document.getElementById('param-alpha-3d').classList.toggle('hidden', method!=='entmax' && method!=='normmax');
  document.getElementById('param-k-3d').classList.toggle('hidden', method!=='topk');
  document.getElementById('param-b-3d').classList.toggle('hidden', method!=='relu-norm');
  document.getElementById('param-budget-3d').classList.toggle('hidden', method!=='budget');
}

function update3DSurface(){
  const method = document.getElementById('method-3d').value;
  const alpha = parseFloat(document.getElementById('alpha-3d').value);
  const k = parseInt(document.getElementById('k-3d').value);
  const b = parseFloat(document.getElementById('b-3d').value);
  const B = parseFloat(document.getElementById('budget-3d').value);
  const comp = parseInt(document.getElementById('component-3d').value);
  const zRange = parseFloat(document.getElementById('z-range').value);
  const res = parseInt(document.getElementById('resolution-3d').value);

  document.getElementById('alpha-3d-value').textContent = alpha.toFixed(2);
  document.getElementById('k-3d-value').textContent = String(k);
  document.getElementById('b-3d-value').textContent = b.toFixed(1);
  document.getElementById('budget-3d-value').textContent = B.toFixed(1);
  document.getElementById('z-range-value').textContent = `±${zRange}`;
  document.getElementById('resolution-3d-value').textContent = String(res);

  const params = {alpha, k, b, budget: B};
  const {z2_vals, z3_vals, z_vals} = computeSurface(method, params, res, zRange, comp);
  const trace = {
    x:z2_vals, y:z3_vals, z:z_vals, 
    type:'surface', 
    colorscale:'Viridis', 
    showscale:true, 
    colorbar:{title:`p${comp+1}`}
  };
  
  const titleMap = { 
    'softmax':'Softmax', 
    'entmax':`α-entmax (α=${alpha.toFixed(2)})`, 
    'sparsemax':'Sparsemax', 
    'normmax':`Normmax (α=${alpha.toFixed(2)})`, 
    'topk':`Top-${k}`, 
    'relu-norm':`ReLU Norm (b=${b.toFixed(1)})`, 
    'budget':`Budget (B=${B.toFixed(1)})`
  };
  
  const layout = { 
    title:`${titleMap[method]}: p${comp+1}(z₂,z₃)`, 
    scene:{
      xaxis:{title:'z₂'}, 
      yaxis:{title:'z₃'}, 
      zaxis:{title:`p${comp+1}`, range:[0,1]}
    }
  };
  
  const config = {displayModeBar: false, responsive: true};
  Plotly.newPlot('plot-3d-surface', [trace], layout, config);
  
  // Restore legend state
  restoreLegendState('plot-3d-surface', '3d-surface');
}

function computeSurface(method, params, resolution, zRange, component){
  const z2_vals=[], z3_vals=[], z_vals=[];
  for (let i=0;i<resolution;i++){
    const row2=[], row3=[], rowz=[];
    for (let j=0;j<resolution;j++){
      const z2 = -zRange + (2*zRange*i)/(resolution-1);
      const z3 = -zRange + (2*zRange*j)/(resolution-1);
      const scores = [0, z2, z3];
      const out = applyTransform(scores, method, params);
      row2.push(z2); row3.push(z3); rowz.push(out[component]);
    }
    z2_vals.push(row2); z3_vals.push(row3); z_vals.push(rowz);
  }
  return {z2_vals, z3_vals, z_vals};
}

// ======== 2D Slices ========
function update2DSliceAll(){
  const n = parseInt(document.getElementById('n-components').value);
  const aEnt = parseFloat(document.getElementById('alpha-entmax').value);
  const aNorm = parseFloat(document.getElementById('alpha-normmax').value);
  const k = parseInt(document.getElementById('k-topk').value);
  const b = parseFloat(document.getElementById('b-relu').value);
  const B = parseFloat(document.getElementById('budget-val').value);
  
  document.getElementById('n-components-value').textContent = String(n);
  document.getElementById('alpha-entmax-value').textContent = aEnt.toFixed(2);
  document.getElementById('alpha-normmax-value').textContent = aNorm.toFixed(2);
  document.getElementById('k-topk-value').textContent = String(k);
  document.getElementById('b-relu-value').textContent = b.toFixed(1);
  document.getElementById('budget-val-value').textContent = B.toFixed(1);

  const z = []; 
  for (let i=0;i<=300;i++) z.push(-3 + 6*i/300);
  
  // Check which methods to show
  const showMethods = {
    'softmax': document.getElementById('show-softmax').checked,
    'entmax': document.getElementById('show-entmax').checked,
    'sparsemax': document.getElementById('show-sparsemax').checked,
    'normmax': document.getElementById('show-normmax').checked,
    'topk': document.getElementById('show-topk').checked,
    'relu-norm': document.getElementById('show-relu').checked,
    'budget': document.getElementById('show-budget').checked
  };
  
  const methods = [
    {key:'softmax', name:'Softmax', show: showMethods['softmax']},
    {key:'entmax', name:`α-entmax (α=${aEnt.toFixed(2)})`, params:{alpha:aEnt}, show: showMethods['entmax']},
    {key:'sparsemax', name:'Sparsemax', show: showMethods['sparsemax']},
    {key:'normmax', name:`Normmax (α=${aNorm.toFixed(2)})`, params:{alpha:aNorm}, show: showMethods['normmax']},
    {key:'topk', name:`Top-${k}`, params:{k}, show: showMethods['topk']},
    {key:'relu-norm', name:`ReLU Norm (b=${b.toFixed(1)})`, params:{b}, show: showMethods['relu-norm']},
    {key:'budget', name:`Budget (B=${B.toFixed(1)})`, params:{budget:B}, show: showMethods['budget']},
  ];

  const traces = methods.filter(m => m.show).map(m => {
    const y = z.map(val => {
      const scores = [val, ...Array(n-1).fill(0)];
      const out = applyTransform(scores, m.key, m.params || {});
      return out[0];
    });
    
    // Check legend state
    const visible = legendState['2d-slice'][m.name] !== false;
    
    return {
      x:z, y, 
      type:'scatter', 
      mode:'lines', 
      name:m.name,
      visible: visible
    };
  });
  
  const layout = { 
    title:`p₁(z) for selected methods (n=${n})`, 
    xaxis:{title:'z'}, 
    yaxis:{title:'p₁', range:[0,1]}
  };
  
  const config = {displayModeBar: false, responsive: true};
  Plotly.newPlot('plot-2d-slice', traces, layout, config);
  
  // Setup legend click handler
  setupLegendClickHandler('plot-2d-slice', '2d-slice');
}

// ======== Side-by-side ========
function drawPanel(plotId, method, params, stateKey){
  const res = 40, zRange = 3, comp = 0;
  if (!method){ 
    Plotly.purge(plotId); 
    return; 
  }
  
  const {z2_vals, z3_vals, z_vals} = computeSurface(method, params, res, zRange, comp);
  const trace = {
    x:z2_vals, y:z3_vals, z:z_vals, 
    type:'surface', 
    colorscale:'Viridis', 
    showscale:false
  };
  
  const layout = { 
    title:`${method} — p₁(z₂,z₃)`, 
    scene:{
      xaxis:{title:'z₂'}, 
      yaxis:{title:'z₃'}, 
      zaxis:{title:'p₁', range:[0,1]}
    }
  };
  
  const config = {displayModeBar: false, responsive: true};
  Plotly.newPlot(plotId, [trace], layout, config);
  
  restoreLegendState(plotId, stateKey);
}

function renderParams(containerId, method, state, onChange){
  const c = document.getElementById(containerId);
  c.innerHTML = '';
  
  function addSlider(id,label,min,max,step,value){
    const wrap = document.createElement('div'); 
    wrap.className='mb-2';
    
    const l = document.createElement('label'); 
    l.className='block text-xs text-gray-600 mb-1'; 
    l.textContent=label; 
    wrap.appendChild(l);
    
    const inp = document.createElement('input'); 
    inp.type='range'; 
    inp.min=min; 
    inp.max=max; 
    inp.step=step; 
    inp.value=value; 
    inp.id=id; 
    inp.className='w-full'; 
    wrap.appendChild(inp);
    
    const span = document.createElement('span'); 
    span.id=id+'-val'; 
    span.className='text-xs text-gray-500'; 
    span.textContent=String(value); 
    wrap.appendChild(span);
    
    c.appendChild(wrap);
    
    inp.addEventListener('input', ()=>{ 
      span.textContent = (method==='entmax'||method==='normmax') ? Number(inp.value).toFixed(2) : String(inp.value); 
      onChange(); 
    });
    
    return inp;
  }
  
  if (method==='entmax') addSlider(containerId+'-alpha','α',1.01,5,0.01,state.alpha ?? 1.5);
  else if (method==='normmax') addSlider(containerId+'-alpha','α',1.01,5,0.01,state.alpha ?? 2.0);
  else if (method==='topk') addSlider(containerId+'-k','k',1,3,1,state.k ?? 2);
  else if (method==='relu-norm') addSlider(containerId+'-b','b',0.1,5,0.1,state.b ?? 1.0);
  else if (method==='budget') addSlider(containerId+'-B','Budget',0.5,5,0.1,state.budget ?? 2.0);
}

function getParamsFromUI(containerId, method){
  function val(id){ 
    const el = document.getElementById(id); 
    return el ? parseFloat(el.value) : undefined; 
  }
  
  if (method==='entmax') return {alpha: val(containerId+'-alpha')};
  if (method==='normmax') return {alpha: val(containerId+'-alpha')};
  if (method==='topk') return {k: parseInt(val(containerId+'-k'))};
  if (method==='relu-norm') return {b: val(containerId+'-b')};
  if (method==='budget') return {budget: val(containerId+'-B')};
  return {};
}

function setupPanel(selectId, paramsDivId, plotId, stateKey){
  const sel = document.getElementById(selectId);
  
  function redraw(){ 
    const m = sel.value || null; 
    const params = getParamsFromUI(paramsDivId, m); 
    drawPanel(plotId, m, params, stateKey); 
  }
  
  function onMethodChange(){
    const m = sel.value || null;
    renderParams(paramsDivId, m, {}, redraw);
    redraw();
  }
  
  sel.addEventListener('change', onMethodChange);
  onMethodChange();
}

// ======== f(τ) Visualization ========
const presets = {
  'uniform': '0, 0, 0, 0, 0',
  'slight': '0.1, 0.2, 0.3, 0.4, 0.5',
  'moderate': '0.2, 0.5, 0.7, 0.9, 1.2',
  'extreme': '0, 1, 2, 3, 5',
  'negative': '-1, -0.5, 0, 0.5, 1'
};

function updateFTauPlot(){
  const preset = document.getElementById('preset-ftau').value;
  const scoresInput = document.getElementById('scores-ftau');

  if (preset !== 'custom') {
    scoresInput.value = presets[preset];
  }

  const scoresText = scoresInput.value;
  const scores = scoresText.split(',').map(s=>parseFloat(s.trim())).filter(v=>!isNaN(v));
  const alpha = parseFloat(document.getElementById('alpha-ftau').value);

  document.getElementById('alpha-ftau-value').textContent = alpha.toFixed(2);

  if (!scores.length) return;

  // === same bounds as in convergence tab ===
  const n = scores.length;
  const maxScore = Math.max(...scores);
  const maxVal = maxScore * (alpha - 1);
  const tauLo = maxVal - 1;                    // lower bisection bound
  const tauHi = maxVal - Math.pow(1 / n, alpha - 1); // upper bisection bound

  // x range slightly extended for nicer view
  const paddingBnd = (tauHi - tauLo) * 0.1;
  const taus = [];
  for (let i=0;i<=400;i++)
    taus.push((tauLo - paddingBnd) + (tauHi - tauLo + 2*paddingBnd)*i/400);

  const fVals = taus.map(t => f(scores, t, alpha));
  const d1 = taus.map(t => fDeriv(scores, t, alpha, 1));
  const d2 = taus.map(t => fDeriv(scores, t, alpha, 2));
  const d3 = taus.map(t => fDeriv(scores, t, alpha, 3));
  const d4 = taus.map(t => fDeriv(scores, t, alpha, 4));
  const tauStar = findTau(scores, alpha);

  document.getElementById('tau-star-value').textContent = tauStar.toFixed(4);

  const showF = document.getElementById('show-f').checked;
  const showD1 = document.getElementById('show-d1').checked;
  const showD2 = document.getElementById('show-d2').checked;
  const showD3 = document.getElementById('show-d3').checked;
  const showD4 = document.getElementById('show-d4').checked;

  const traces = [
    {x:taus, y:fVals, type:'scatter', mode:'lines', name:'f(τ)', visible: legendState['ftau']['f(τ)'] !== false && showF, line:{width:2}},
    {x:taus, y:d1,    type:'scatter', mode:'lines', name:"f'(τ)", visible: legendState['ftau']["f'(τ)"] !== false && showD1, line:{width:2}},
    {x:taus, y:d2,    type:'scatter', mode:'lines', name:"f''(τ)", visible: legendState['ftau']["f''(τ)"] !== false && showD2, line:{width:2}},
    {x:taus, y:d3,    type:'scatter', mode:'lines', name:"f'''(τ)", visible: legendState['ftau']["f'''(τ)"] !== false && showD3, line:{width:2}},
    {x:taus, y:d4,    type:'scatter', mode:'lines', name:"f⁽⁴⁾(τ)", visible: legendState['ftau']["f⁽⁴⁾(τ)"] !== false && showD4, line:{width:2}},
  ];

  // y-range based on visible traces
  const visibleYs = [];
  if (traces[0].visible) visibleYs.push(...fVals);
  if (traces[1].visible) visibleYs.push(...d1);
  if (traces[2].visible) visibleYs.push(...d2);
  if (traces[3].visible) visibleYs.push(...d3);
  if (traces[4].visible) visibleYs.push(...d4);
  const yMin = visibleYs.length ? Math.min(...visibleYs) : -1;
  const yMax = visibleYs.length ? Math.max(...visibleYs) : 1;
  const yPad = (yMax - yMin) * 0.1 || 0.5;

  const layout = {
    title:`f(τ) and higher derivatives (α=${alpha.toFixed(2)})`,
    xaxis:{title:'τ'},
    yaxis:{title:'value', range:[yMin - yPad, yMax + yPad]},
    shapes: [
      // shared bisection band
      {
        type: 'rect',
        x0: tauLo,
        x1: tauHi,
        y0: yMin - yPad,
        y1: yMax + yPad,
        // fillcolor: 'rgba(135, 206, 250, 0.25)', // light blue
        fillcolor:'gold',
        opacity: 0.15,
        line: {width:0},
        layer: 'below'
      },
      // vertical line for τ* (like convergence)
      {
        type: 'line',
        x0: tauStar,
        x1: tauStar,
        y0: yMin - yPad,
        y1: yMax + yPad,
        line: {
          color: 'gold',
          width: 3,
          dash: 'dot'
        }
      }
    ],
    annotations: [
      {
        x: tauStar,
        y: yMin - yPad * 0.4,
        text: `τ* = ${tauStar.toFixed(4)}`,
        showarrow: false,
        font: {size: 12, color: 'black'},
        bgcolor: 'rgba(0,0,0,0.3)',
        borderpad: 3
      },
      {
        x: tauLo,
        y: yMax + yPad,
        text: `τ_lo = ${tauLo.toFixed(4)}`,
        showarrow: false,
        font: {size: 11, color: 'black'},
        bgcolor: 'rgba(0,0,0,0.3)',
        borderpad: 3
      },
      {
        x: tauHi,
        y: yMax + yPad,
        text: `τ_hi = ${tauHi.toFixed(4)}`,
        showarrow: false,
        font: {size: 11, color: 'black'},
        bgcolor: 'rgba(0,0,0,0.3)',
        borderpad: 3
      }
    ]
  };



  const config = {displayModeBar: false, responsive: true};
  Plotly.newPlot('plot-ftau', traces, layout, config);

  setupLegendClickHandler('plot-ftau', 'ftau');
}


// ======== Convergence ========
function fPrime(scores, tau, alpha){ return fDeriv(scores, tau, alpha, 1); }

function newtonMethod(scores, alpha, tauInit, maxIter=20){
  const iters = [];
  let tau = tauInit;
  for (let i=0;i<maxIter;i++){
    const fv = f(scores, tau, alpha);
    const fp = fPrime(scores, tau, alpha);
    iters.push({iter:i, tau, f:fv});
    if (Math.abs(fv) < 1e-9 || Math.abs(fp) < 1e-12) break;
    tau = tau - fv / fp;
  }
  // Add final iteration if we didn't break on last iter
  if (iters.length < maxIter) {
    const fv = f(scores, tau, alpha);
    iters.push({iter: iters.length, tau, f: fv});
  }
  return iters;
}

function bisectionMethod(scores, alpha, maxIter=30){
  const n = scores.length;
  const maxScore = Math.max(...scores);
  const X = scores.map(s => s * (alpha - 1));
  const maxVal = maxScore * (alpha - 1);
  let a = maxVal - Math.pow(1, alpha - 1);
  let b = maxVal - Math.pow(1 / n, alpha - 1);
  let fa = f(scores, a, alpha), fb = f(scores, b, alpha);
  const iters = [{iter:0, tau:a, f:fa}, {iter:1, tau:b, f:fb}];
  for (let i=2;i<maxIter;i++){
    const m = 0.5*(a+b);
    const fm = f(scores, m, alpha);
    iters.push({iter:i, tau:m, f:fm});
    if (fa*fm <= 0){ b = m; fb = fm; } else { a = m; fa = fm; }
    if (Math.abs(fm) < 1e-9) break;
  }
  return iters;
}

function secantMethod(scores, alpha, tau0, tau1, maxIter=20){
  const iters = [];
  let t0 = tau0, t1 = tau1;
  let f0 = f(scores, t0, alpha), f1 = f(scores, t1, alpha);
  iters.push({iter:0, tau:t0, f:f0}); 
  iters.push({iter:1, tau:t1, f:f1});
  for (let i=2;i<maxIter;i++){
    const denom = (f1 - f0);
    if (Math.abs(denom) < 1e-12) break;
    const t2 = t1 - f1*(t1 - t0)/denom;
    const f2 = f(scores, t2, alpha);
    iters.push({iter:i, tau:t2, f:f2});
    if (Math.abs(f2) < 1e-9) break;
    t0=t1; f0=f1; t1=t2; f1=f2;
  }
  // Secant already includes final iteration since it pushes before checking convergence
  return iters;
}

function halleyMethod(scores, alpha, tauInit, maxIter=20){
  const iters = [];
  let tau = tauInit;
  for (let i=0;i<maxIter;i++){
    const fv = f(scores, tau, alpha);
    const fp = fPrime(scores, tau, alpha);
    const fpp = fSecondDeriv(scores, tau, alpha);
    iters.push({iter:i, tau, f:fv});
    if (Math.abs(fv) < 1e-9 || Math.abs(fp) < 1e-12) break;
    const denom = fp - (fv * fpp) / (2 * fp);
    if (Math.abs(denom) < 1e-12) break;
    tau = tau - fv / denom;
  }
  // Add final iteration if we didn't break on last iter
  if (iters.length < maxIter) {
    const fv = f(scores, tau, alpha);
    iters.push({iter: iters.length, tau, f: fv});
  }
  return iters;
}

function updateTauInitRange(){
  const scoresText = document.getElementById('scores-conv').value;
  const scores = scoresText.split(',').map(s=>parseFloat(s.trim())).filter(v=>!isNaN(v));
  const alpha = parseFloat(document.getElementById('alpha-conv').value);
  
  if (!scores.length) return;
  
  // Use the theoretical bisection bounds from PyTorch
  const n = scores.length;
  const maxScore = Math.max(...scores);
  const maxVal = maxScore * (alpha - 1);
  
  // tau_lo = max_val - gp(1, alpha) = max_val - 1^(alpha-1) = max_val - 1
  // tau_hi = max_val - gp(1/n, alpha) = max_val - (1/n)^(alpha-1)
  const tauLo = maxVal - 0.99;
  const tauHi = maxVal - 0.99 * Math.pow(1 / n, alpha - 1);
  
  const slider = document.getElementById('tau-init');
  slider.min = tauLo;
  slider.max = tauHi;
  
  // Set initial value to middle if current value is out of bounds
  const currentVal = parseFloat(slider.value);
  if (currentVal < tauLo || currentVal > tauHi) {
    slider.value = (tauLo + tauHi) / 2;
  }
  
  const tauInit = parseFloat(slider.value);
  document.getElementById('tau-init-value').textContent = `${tauInit.toFixed(4)} (range: [${tauLo.toFixed(4)}, ${tauHi.toFixed(4)}])`;
}

function updateConvergencePlot(){
  const scoresText = document.getElementById('scores-conv').value;
  const scores = scoresText.split(',').map(s=>parseFloat(s.trim())).filter(v=>!isNaN(v));
  const alpha = parseFloat(document.getElementById('alpha-conv').value);
  const tauInit = parseFloat(document.getElementById('tau-init').value);
  const method = document.getElementById('method-conv').value;
  
  document.getElementById('alpha-conv-value').textContent = alpha.toFixed(2);
  
  if (!scores.length) return;

  // Update tau init range
  updateTauInitRange();

  // Find optimal tau
  const tauStar = findTau(scores, alpha);

  // Calculate plot range with padding
  const minZ = Math.min(...scores);
  const maxZ = Math.max(...scores);
  const tmin = minZ - 1;
  const tmax = maxZ + 1;
  
  const taus = []; 
  for (let i=0;i<=400;i++) taus.push(tmin + (tmax-tmin)*i/400);
  const fVals = taus.map(t => f(scores, t, alpha));

  let iters;
  if (method==='newton') iters = newtonMethod(scores, alpha, tauInit, 25);
  else if (method==='bisection') iters = bisectionMethod(scores, alpha, 30);
  else if (method==='secant') {
    // Use two points within the valid range for secant
    const n = scores.length;
    const maxScore = Math.max(...scores);
    const maxVal = maxScore * (alpha - 1);
    const tauLo = maxVal - 1;
    const tauHi = maxVal - Math.pow(1 / n, alpha - 1);
    const tau0 = tauLo + (tauHi - tauLo) * 0.3;
    const tau1 = tauLo + (tauHi - tauLo) * 0.7;
    iters = secantMethod(scores, alpha, tau0, tau1, 25);
  } else {
    iters = halleyMethod(scores, alpha, tauInit, 25);
  }

  // Calculate f(tau) range INCLUDING the iteration points
  const allFVals = [...fVals, ...iters.map(it => it.f)];
  const fMin = Math.min(...allFVals);
  const fMax = Math.max(...allFVals);
  const fPadding = Math.max((fMax - fMin) * 0.2, 0.5);

  const curve = {
    x:taus, 
    y:fVals, 
    type:'scatter', 
    mode:'lines', 
    name:'f(τ)',
    line: {color: 'blue', width: 2}
  };

  // Iteration markers with numbers inside
  const markerTrace = {
    x: iters.map(p => p.tau),
    y: iters.map(p => p.f),
    type: 'scatter',
    mode: 'markers+text',
    marker: {size: 24, color: 'red', line: {width: 2, color: 'darkred'}},
    text: iters.map(p => String(p.iter)),
    textposition: 'middle center',
    textfont: {color: 'white', size: 11, family: 'Arial Black'},
    name: 'Iterations'
  };

  const optimalTauLine = {
    x: [tauStar, tauStar],
    y: [fMin - fPadding, fMax + fPadding],
    type: 'scatter',
    mode: 'lines',
    line: {
      color: 'gold',
      width: 3,
      dash: 'dot'
    },
    showlegend: false,
    hoverinfo: 'skip',
  };

  // Check legend state
  const curveVisible = legendState['convergence']['f(τ)'] !== false;
  const markerVisible = legendState['convergence']['Iterations'] !== false;

  const traces = [
    optimalTauLine, 
    {...curve, visible: curveVisible},
    {...markerTrace, visible: markerVisible},
  ];

  // Create arrow annotations
  const annotations = [];
  for (let i = 0; i < iters.length - 1; i++) {
    const from = iters[i];
    const to = iters[i + 1];
    
    annotations.push({
      x: to.tau,
      y: to.f,
      ax: from.tau,
      ay: from.f,
      xref: 'x',
      yref: 'y',
      axref: 'x',
      ayref: 'y',
      showarrow: true,
      arrowhead: 2,
      arrowsize: 1,
      arrowwidth: 2,
      arrowcolor: 'rgba(255, 100, 100, 0.6)'
    });
  }

  // Add annotation for optimal tau
  annotations.push({
    x: tauStar,
    y: fMin - fPadding * 0.5,
    text: `τ* = ${tauStar.toFixed(4)}`,
    showarrow: false,
    font: {size: 14, color: 'gold', family: 'Arial Black'},
    bgcolor: 'rgba(0, 0, 0, 0.7)',
    borderpad: 4
  });

  const layout = {
    title:`Convergence — ${method} (Final: τ=${iters[iters.length-1].tau.toFixed(4)}, f(τ)=${iters[iters.length-1].f.toFixed(6)})`,
    xaxis:{title:'τ', range: [tmin, tmax]}, 
    yaxis:{title:'f(τ)', range: [fMin - fPadding, fMax + fPadding]},
    annotations: annotations,
    shapes: [
      // Horizontal line at y=0
      {
        type: 'line',
        x0: tmin,
        x1: tmax,
        y0: 0,
        y1: 0,
        line: {
          color: 'black',
          width: 2,
          dash: 'dash'
        }
      },
      // // Vertical line at optimal tau
      // {
      //   type: 'line',
      //   x0: tauStar,
      //   x1: tauStar,
      //   y0: fMin - fPadding,
      //   y1: fMax + fPadding,
      //   line: {
      //     color: 'gold',
      //     width: 3,
      //     dash: 'dot'
      //   },
      //   layer: 'below'
      // }
    ]
  };

  const config = {displayModeBar: false, responsive: true};
  Plotly.newPlot('plot-convergence', traces, layout, config);

  setupLegendClickHandler('plot-convergence', 'convergence');
}

// ======== Legend State Management ========
function setupLegendClickHandler(plotId, stateKey){
  const plot = document.getElementById(plotId);
  
  plot.on('plotly_legendclick', function(data) {
    const traceName = plot.data[data.curveNumber].name;
    const currentVisible = plot.data[data.curveNumber].visible;
    
    // Store the state
    if (currentVisible === true || currentVisible === undefined) {
      legendState[stateKey][traceName] = false;
    } else {
      legendState[stateKey][traceName] = true;
    }
    
    return true; // Allow default behavior
  });
}

function restoreLegendState(plotId, stateKey){
  const plot = document.getElementById(plotId);
  
  plot.on('plotly_afterplot', function() {
    const update = {visible: []};
    const indices = [];
    
    plot.data.forEach((trace, idx) => {
      if (trace.name && legendState[stateKey][trace.name] === false) {
        update.visible.push(false);
        indices.push(idx);
      }
    });
    
    if (indices.length > 0) {
      Plotly.restyle(plotId, update, indices);
    }
  });
}

// ================= Tabs & events =================
function switchTab(target){
  document.querySelectorAll('.tab-button').forEach(btn=>{
    const active = btn.getAttribute('data-tab') === target;
    btn.classList.toggle('text-indigo-600', active);
    btn.classList.toggle('border-indigo-600', active);
    btn.classList.toggle('text-gray-500', !active);
    btn.classList.toggle('border-transparent', !active);
  });
  document.querySelectorAll('.tab-panel').forEach(p=>{
    p.classList.toggle('hidden', p.getAttribute('data-panel') !== target);
  });
  
  // Resize plots when tab becomes visible
  setTimeout(() => {
    if (target === '3d-surfaces') {
      Plotly.Plots.resize('plot-3d-surface');
    } else if (target === '2d-slices') {
      Plotly.Plots.resize('plot-2d-slice');
    } else if (target === 'comparison') {
      Plotly.Plots.resize('plot-comp-a');
      Plotly.Plots.resize('plot-comp-b');
      Plotly.Plots.resize('plot-comp-c');
    } else if (target === 'f-tau') {
      Plotly.Plots.resize('plot-ftau');
    } else if (target === 'convergence') {
      Plotly.Plots.resize('plot-convergence');
    }
  }, 100);
}

document.querySelectorAll('.tab-button').forEach(btn=> {
  btn.addEventListener('click', ()=> switchTab(btn.getAttribute('data-tab')));
});

// 3D Surface events
['method-3d','alpha-3d','k-3d','b-3d','budget-3d','component-3d','z-range','resolution-3d'].forEach(id=>{
  const el = document.getElementById(id);
  if (id==='method-3d') el.addEventListener('change', ()=> { updateParamVisibility3D(); update3DSurface(); });
  else el.addEventListener('input', update3DSurface);
});

// 2D Slice events
['n-components','alpha-entmax','alpha-normmax','k-topk','b-relu','budget-val'].forEach(id=>{
  document.getElementById(id).addEventListener('input', update2DSliceAll);
});

// Method selection checkboxes for 2D slice
['show-softmax', 'show-entmax', 'show-sparsemax', 'show-normmax', 'show-topk', 'show-relu', 'show-budget'].forEach(id => {
  document.getElementById(id).addEventListener('change', update2DSliceAll);
});

// f(τ) events
document.getElementById('preset-ftau').addEventListener('change', updateFTauPlot);
document.getElementById('scores-ftau').addEventListener('change', () => {
  document.getElementById('preset-ftau').value = 'custom';
  updateFTauPlot();
});
document.getElementById('alpha-ftau').addEventListener('input', updateFTauPlot);
['show-f', 'show-d1', 'show-d2', 'show-d3', 'show-d4'].forEach(id => {
  document.getElementById(id).addEventListener('change', updateFTauPlot);
});

// Convergence events
document.getElementById('scores-conv').addEventListener('change', () => {
  updateTauInitRange();
  updateConvergencePlot();
});
['alpha-conv','tau-init','method-conv'].forEach(id=>{
  document.getElementById(id).addEventListener('input', updateConvergencePlot);
});

// Initial renders
updateParamVisibility3D();
update3DSurface();
update2DSliceAll();
setupPanel('m1','m1-params','plot-comp-a', 'comparison-a');
setupPanel('m2','m2-params','plot-comp-b', 'comparison-b');
setupPanel('m3','m3-params','plot-comp-c', 'comparison-c');
updateFTauPlot();
updateTauInitRange();
updateConvergencePlot();
</script>
</body>
</html>